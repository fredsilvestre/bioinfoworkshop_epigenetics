---
title: "Working with bioconductor - workshop 2026 part1"
author: "Frédéric Silvestre"
date: "30/01/2026"
output:
  pdf_document: default
  html_document: default
---

This first part of the workshop aims to introduce bioconductor packages and to work with sequences and genomic objects in R. It will also introduce Rmarkdown.


# 0° Preparation of the working environment


## Install R v4.5.2 and update RStudio

Go to the CRAN website.
For Windows Users - https://cran.r-project.org/bin/windows/base/.
For Mac Users - https://cran.r-project.org/bin/macosx/
Download the latest R installer.
Run the installer, and it will guide you through the installation process.
After updating R, open RStudio. Close RStudio if it is already opened and open it again.
RStudio will automatically detect the updated R version. Run this command R.version.string to check the R version RStudio is using.

The R packages are located in (for mac users) : computername/Library/Frameworks/R.framework/Versions/X.XX/Resources/library

Optional:
Copy all the old R version packages to the new version. Update the packages.

Install the last version of R studio:
https://posit.co/download/rstudio-desktop/ 

```{r eval=F}

R.version.string
#you can also use the command line R --version

old.packages()

#Optional if there is "no repository set":
#options(repos = c(CRAN = "https://cloud.r-project.org/")) #seta  CRAN mirror (repository URL) to check for package updates

update.packages(checkBuilt = TRUE, ask = FALSE)

packageStatus()

sessionInfo()

```


## General setup of RMarkdown chunks and common shortcuts (for MacOS)


```{r eval=F}

if(!requireNamespace("knitr", quietly=TRUE)){
        install.packages("knitr")
library(knitr)}

if(!requireNamespace("rmarkdown", quietly=TRUE)){
        install.packages("rmarkdown")
library(rmarkdown)}

if(!requireNamespace("tinytex", quietly=TRUE)) { 
        install.packages("tinytex")
library(tinytex) }
#this package will permit to knit into a pdf file

if(!tinytex:::is_tinytex()){
    tinytex::install_tinytex()
}
# Install the LaTeX distribution (only needs to be done once)

```

```{r eval=T}
knitr::opts_chunk$set(eval=F, results="markup", echo = T, warning=F, error=T)
```

Change the general options in each chunk: eval=T (run the chunk); results=markup (show the results) or hide ; echo=T (show the code) ; include=T (include the chunk)    
Option/CTL I to create a chunk  
Shift/option ( to [ 
Option ( to { 
| shift/option L  
~ option n  
shift/option/command G > go to line xxx
double space to change the paragraph  


## Set working directory 


```{r eval=T}
setwd("/Users/fsilvest/Dropbox/studentpack_2026") # adapt to your computer
getwd()

ls()
rm(list = ls())

#tempdir() #where to save temporary data from R
#list.files(tempdir())

#unlink(tempdir(), recursive = TRUE) # To clean the tempdir. The temp directory usually cleans itself up when you close R. Only use this if you're experiencing specific issues with temp files, and always restart R immediately afterward

#dev.list()
#dev.off() #to reset the graph device options

```


## Install Bioconductor 3.22 and requested packages


Bioconductor: https://www.bioconductor.org/
https://www.bioconductor.org/install/ 

search for available packages: https://www.bioconductor.org/packages/release/BiocViews.html#___Software

```{r}
# Check the version of BiocManager on your computer
BiocManager::version()
vignette("BiocManager", package = "BiocManager")


if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
BiocManager::install(version = "3.22")
library(BiocManager)}

#options(repos = BiocManager::repositories())
#getOption("repos")
#BiocManager::repositories()

#To check the number of packages available in Bioconductor
avail <- BiocManager::available()
length(avail)

#Try to install a package
BiocManager::install("Biostrings")

#update your packages
BiocManager::install()
```


```{r}
if (!require("stringi", quietly = TRUE)) {
      install.packages("stringi",type="mac.binary") 
      library(stringi)}

#mac.binary > if an error message appears (aucun package nommé ‘stringi’ n'est trouvé)

bioc_packages <- c("GenomicRanges", "GenomeInfoDb", "IRanges", "Biostrings", "BSgenome", "AnnotationHub", "SummarizedExperiment", "airway", "GenomicFeatures", "SGSeq", "qvalue", "pwalign")  

for (pkg in bioc_packages) {
    if (!require(pkg, quietly = TRUE)) {
        BiocManager::install(pkg, ask = FALSE)  # Install without asking for confirmation
        library(pkg, character.only = TRUE)
    }
}

```


## To obtain help

```{r}

?mean
help.start()
help(package = "GenomicRanges")
vignette()
vignette("ExpressionSetIntroduction")
browseVignettes("GenomicRanges")

```


## To save and load R objects


```{r}

saveRDS(tiles, file="RDS/tiles1.RDS")
b <- readRDS("RDS/tiles1.RDS")

```




# 1° Working with sequences


## Create a DNAstring object


The DNAString and DNAStringSet classes in Bioconductor's Biostrings package are used for efficiently storing and manipulating DNA sequences in R.

```{r}

DNA <- DNAString("GATTACCGA") #create a Biostrings object
DNA
class(DNA)

a <- as.character(DNA) #give the sequence
class(a)
a

length(DNA) #count the number of nucleotides
b <- DNA[2:3]
b

DNA2 <- DNAString("GCATGCGA")
DNA2

DNA21 <- DNAString("TCCGGANG") #N is an ambiguous base
DNA21

DNA22 <- xscat(DNA, DNA2) #combine 2 DNA sequences
DNA22

```


## Create a set of DNAstring objects


```{r}

DNA3 <- DNAStringSet(c("TCGAG", "AAGCGTAT")) 
DNA3
class(DNA3)
length(DNA3) #count the number of objects Biostring
width(DNA3) #count the number of nucleotides
sum(width(DNA3))

set1 <- DNA3[1]
set1
width(set1)

unique(DNA3)
duplicated(DNA3)

DNA4 <- DNAStringSet(c("TCA", "AAATCG", "TCA")) 
DNA4
unique(DNA4)
dup <- duplicated(DNA4)
dup
sum(dup, na.rm=T) #count the number of duplicate sequences

```


## Combine 2 DNAString objects


```{r}

seqs1 <- DNAStringSet(list(seq1=DNA, seq2=DNA2)) #combine and give a name
seqs1
class(seqs1)
seqs1$seq1

```


## Common operations with DNAstring objects


```{r}

reverseComplement(DNA)
DNA

reverseComplement(seqs1)

rna_seq <- RNAString(DNA)  # Convert DNA to RNA
rna_seq

matchPattern("CG", DNA)  # Find occurrences of "CG" in DNA

mp <- matchPattern("CG", DNA22)  # Find occurrences of "CG" in DNA22
class(mp)
length(mp)
DNA22

```


## Performing Pairwise Alignment


It requests the package pwalign
Solves (Needleman-Wunsch) global alignment, (Smith-Waterman) local alignment, and (ends-free) overlap alignment problems.
The alignment score is a numerical value that measures the quality of an alignment between two sequences. It is calculated based on:
Matches (rewarded with a positive score)
Mismatches (penalized with a negative score)
Gap opening penalties (penalized)
Gap extension penalties (penalized)

```{r}

#A global alignment aligns sequences from start to end, even if mismatches are required.

alignment <- pairwiseAlignment(DNA, DNA2, type = "global", scoreOnly=F)
alignment

?pairwiseAlignment

#A local alignment finds the best matching subsequence within the sequences.

alignment2 <- pairwiseAlignment(DNA, DNA2, type = "local", scoreOnly=F)
alignment2

#An overlap alignment is useful when two sequences should be aligned only where they overlap.

alignment3 <- pairwiseAlignment(DNA, DNA2, type = "overlap", scoreOnly=F)
alignment3

```

Which type to choose?

Global: When comparing full-length sequences (e.g., comparing two genes)
Local: When looking for conserved domains or motifs
Overlap: Finding where two sentence fragments join together



## Importing and exporting FASTA files

Seq in FASTA format of the gene MeCP2 of mangrove rivulus (downloaded from https://www.ensembl.org/)


```{r}

seqs2 <- readDNAStringSet(filepath="Sequences/mecp2.fa", format="fasta") 

seqs2
names(seqs2)
class(seqs2)
length(seqs2)
width(seqs2)

#write your sequence in a fasta file
writeXStringSet(DNA4, "DNA.fasta")
seqs21 <- readDNAStringSet(filepath="DNA.fasta", format="fasta") 
seqs21

vmatchPattern("AGGAGGT", seqs2) #retrieve the motif in the sequence

subseq1 <- subseq(seqs2, 7327,7333)
subseq1
class(subseq1)

vmatchPattern("TAAGAAGTTTACAC", seqs2)

subseq2 <- subseq(seqs2, 934,947)
subseq2

print(as.character(seqs2))

letterFrequency(seqs2, "T")
letterFrequency(seqs2,"GC") #G or C

#Calculate the GC contain

letterFrequency(seqs2,"GC")/width(seqs2) #GC contain

dinucleotideFrequency(seqs2)

# translate to amino acid
translate(subseq1)

#Subset the sequence between position 3000 and 3100
subseq3 <- subseq(seqs2, 3000,3100)
subseq3

```


## Combine 2 subsequences in a single DNAStringSet


```{r}

#combine the 2 sequences of MeCP2 gene (subseq1 and subseq2) in 2 DNAStringSet object of length 1, and in 1 DNAStringSet object of length 2

singleseq2 <- c(unlist(subseq2), unlist(subseq1)) #unlist to transform DNAStringSet object into a DNAString object
singleseq2

seqlist2 <- list(subseq2, subseq1)
seqlist2

# sort the length of each sequence
widths2 <- sapply(seqlist2, function(x) sum(width(x)))
widths2

#isolate sequences of each sorted length
seqviews2 <- successiveViews(singleseq2, widths2)
seqviews2

#reconstruct a DNAStringSet object with the 2 sequences
seqstring2 <- as(seqviews2, "DNAStringSet")
seqstring2

```


# 2° Work with set of genes: GRanges

A GRanges object is a fundamental data structure in Bioconductor (R's bioinformatics ecosystem) for working with genomic intervals or ranges.
At its core, a GRanges object stores genomic locations with three essential pieces of information:
1. Chromosome (seqnames) - which chromosome the region is on (like "chr1", "chr2", etc.)
2. Ranges - the start and end positions on that chromosome
3. Strand - whether the feature is on the positive (+), negative (-), or unspecified (*) strand
You can also attach additional metadata columns to store extra information about each range, like gene names, scores, or any other annotations.
GRanges objects are particularly useful because they come with many built-in operations for genomic analysis, such as finding overlaps between ranges, calculating distances, subsetting by genomic location, and merging intervals. This makes them essential for tasks like ChIP-seq analysis, RNA-seq, variant calling, and other genomics workflows where you need to work with genomic coordinates efficiently.

Reminder:

+ strand (coding):    5'- ATG GCA TTC -3'
- strand (template):  3'- TAC CGT AAG -5'
                           ↑ reading direction
messenger RNA:        5'- AUG GCA UUC -3'

```{r}

?GRanges

myseq <- DNAString("ACCATTGATTAT")

myset <- DNAStringSet(list(chrI=myseq, chrII=DNAString("ACGTACGT")))
myset

range1 <- GRanges("chrI", IRanges(start = 3, end = 6), strand = "+")
range1
class(range1)

seqnames(range1)
strand(range1)
getSeq(myset, range1)

?getSeq

mcols(range1)$wobble <- 10 #create metadata columns
range1

range2 <- GRanges(c("chrZ","chrY"), IRanges(start=c(5,10), end=c(35,45)), strand="+")
range2
range3 <- c(range1, range2)
range3
range3[1:2,]


#Exercice: Create a GRanges object with 2 sequences on chromosomes 2 and 7, ranges 46-89 and 23-90, on strand + and -.

XXXX
XXXX

```

Rle = Run-Length Encoding



## Download gtf file from your species: http://www.ensembl.org/Kryptolebias_marmoratus/Info/Index

https://www.ensembl.org/info/website/upload/gff.html 
To find all the files to download here: https://www.ensembl.org/info/data/ftp/index.html

A GTF (Gene Transfer Format) file is a tab-delimited text file used to store genome annotation data, such as genes, transcripts, and exons. It is commonly used in genomics, RNA sequencing (RNA-Seq), and bioinformatics.

A GTF file consists of nine required columns:

Column #	Column Name	Description
1	seqname	Chromosome or scaffold (e.g., chr1, chrX)
2	source	Annotation source (e.g., Ensembl, NCBI, HAVANA)
3	feature	Type of feature (gene, transcript, exon, CDS, etc.)
4	start	Start position (1-based)
5	end	End position
6	score	Score (usually . if not available)
7	strand	+ (forward) or - (reverse) strand
8	frame	Reading frame (0, 1, 2 for CDS features, . otherwise)
9	attributes	Extra information (e.g., gene name, transcript ID, etc.)


```{r}

features <- import("Sequences/genomic.gtf")
features

mcols(features) <- mcols(features)[,c("type","gene","gene_id")]
unique(features$gene)
features
class(features)

mecp2 <- subset(features, gene=="mecp2")
mecp2

exon <- mecp2[mecp2$type=="exon"]
exon

```


## To find references for different species using AnnotationHub

AnnotationHub is a Bioconductor service that provides centralized access to a huge collection of genomic annotation data.
What it does:
Instead of manually downloading annotation files (GTF, FASTA, BED files, etc.) from various websites, AnnotationHub lets you browse and download them directly from R with a few lines of code.
What's available:

Reference genomes (DNA sequences)
Gene annotations (GTF/GFF files with gene locations)
Regulatory elements (enhancers, promoters, TFBS)
Epigenetic data (ChIP-seq peaks, histone marks)
Conservation scores
Variant databases
And much more...

```{r}

package = "AnnotationHub"

#As of AnnotationHub (>2.23.2), default caching location has changed. Run the code below to adapt the cache
oldcache = path.expand(rappdirs::user_cache_dir(appname=package))
    setAnnotationHubOption("CACHE", oldcache)
    ah = AnnotationHub(localHub=TRUE)
    ## removes old location and all resources
    removeCache(ah, ask=FALSE)

    ## create the new default caching location
    newcache = tools::R_user_dir(package, which="cache")
    setAnnotationHubOption("CACHE", newcache)
    ah = AnnotationHub()

    
browseVignettes("AnnotationHub")

ah <- AnnotationHub()
length(ah)

colnames(mcols(ah))
unique(ah$species)

records <- query(ah,"Kryptolebias marmoratus")
records
table(records$genome)
table(records$sourcetype)
mcols(records)[,c("title", "rdataclass", "sourcetype")]

km <- ah[["AH64640"]]
km

```


## Working with expressionSet

An ExpressionSet is a specialized data structure in Bioconductor used to store gene expression data along with associated metadata (such as sample information and feature annotations). It is commonly used in microarray and RNA-Seq analysis.

```{r}

exprs <- as.matrix(read.table("Sequences/expressiondata.txt", header=TRUE, sep="\t", row.names=1))

exprs
class(exprs)
dim(exprs)
colnames(exprs)
head(exprs[,1:3])
head(exprs[1:3,])
head(exprs[1:3])

minimalSet <- ExpressionSet(assayData=exprs)
minimalSet

pData <- read.table("Sequences/pData.txt", row.names=1, header=TRUE, sep="\t")
pData

all(rownames(pData)==colnames(exprs))

names(pData)
class(pData)
sapply(pData, class)
pData[c(2, 4), c("Sex")]
pData[pData$Age>20,]

phenoData <- new("AnnotatedDataFrame", data=pData)
phenoData

exampleSet <- ExpressionSet(assayData=exprs, phenoData=phenoData)
exampleSet
exampleSet$Sex[1:3]
featureNames(exampleSet)
sampleNames(exampleSet)
varLabels(exampleSet)

mat <- exprs(exampleSet)
mat
males <- exampleSet[,exampleSet$Sex=="M"]
males
exprs(males)

```


## SummarizedExperiment for RNAseq

A SummarizedExperiment is a Bioconductor data structure designed to store high-throughput genomic data (e.g., RNA-Seq, ChIP-Seq, microarrays) along with associated metadata.

SummarizedExperiment and ExpressionSet are both containers for storing high-throughput genomic data (like RNA-seq or microarray experiments), but SummarizedExperiment is the modern replacement for ExpressionSet.
Key differences:
ExpressionSet (older, legacy)

Designed primarily for microarray data
Stores expression matrix + sample metadata + feature metadata
Uses basic data structures
Being phased out

SummarizedExperiment (modern, recommended)

Designed for any genomic assay (RNA-seq, ChIP-seq, methylation, etc.)
Can store multiple assays in one object (e.g., counts + normalized counts)
Uses GRanges for feature metadata, linking data directly to genomic coordinates
More flexible and powerful
Actively maintained and developed


A SummarizedExperiment consists of:

Component	Description	Access Function
assay (Expression Data)	Numeric matrix of counts (genes × samples)	assay(se)
colData (Sample Metadata)	Phenotypic data (e.g., treatment, condition)	colData(se)
rowRanges (Feature Metadata)	Genomic ranges of genes/transcripts	rowRanges(se)
metadata (Experiment Info)	Additional study-level data	metadata(se)


The rowRanges stores genomic coordinates as GRanges objects, so you can:

Directly overlap your data with genomic features
Subset by genomic regions
Integrate with other Bioconductor tools seamlessly

```{r}

se <- SummarizedExperiment(
  assays = list(counts = exprs),
  #rowRanges = gene_ranges, # GRanges with gene locations
  colData = pData
)

se



data(airway, package="airway")
se <- airway
se
assays(se)
assays(se)$counts
rowRanges(se)
colData(se)
se[,se$dex=="trt"]
metadata(se)
```


## Correction for multiple comparisons


```{r}

?qvalue # proportion of false positive when the test is positive ; compare to Bonferoni and FDR

data(hedenfalk)

# Method 1: q-values (less conservative, controls False Discovery Rate)
qvalues <- qvalue(hedenfalk$p, fdr.level=0.05, method="bootstrap")$q
qvalues

# Method 2: Bonferroni correction (very conservative)
bonferroni <- p.adjust(hedenfalk$p, method="bonferroni")

# Method 3: FDR/Benjamini-Hochberg (moderately conservative)
fdr <- p.adjust(hedenfalk$p, method="fdr")

# Plot all three methods for comparison
plot(hedenfalk$p,qvalues,pch=19,ylim=c(0,1),
     xlab="raw P-values",ylab="adjusted P-values")
points(hedenfalk$p,bonferroni,pch=19,col="red")
points(hedenfalk$p,fdr,pch=19,col="blue")
legend("bottomright",legend=c("q-value","FDR (BH)","Bonferroni"),
       fill=c("black","blue","red"))
```



# 3° Exercice

Integrated Exercise: Using DNAString, GRanges, and GTF in Genomic Analysis
Objective: Combine DNA sequence (DNAString), genomic intervals (GRanges), and gene annotations (GTF) to extract and analyze exonic sequences from a gene.

Answer these questions:

- what is the total number of nucleotides in the gene GRID2 from Kryptolebias marmoratus ?
- how many exons are there in GRID2 ?
- for the valid exons (those within the valid boundaries), how many CpG dinucleotides ?
- what is the GC content of these valid exons ?


```{r}

## Step 1: Load Required Libraries ----


## Step 2: Load the GTF File and Extract Exon Coordinates ----

# Filter for exons only

## Step 3: Load the GRID2 Genomic Sequence ----

## Step 4: Extract GRID2 Exons ----
# Filter exons for GRID2 gene only

## Step 5: Adjust Coordinates to Match the FASTA Sequence ----
# The GTF coordinates are genomic (chromosome-based), but our FASTA contains
# just the GRID2 gene region. We need to convert to gene-relative coordinates.

# Get the gene entry to find the gene start position
gene_grid2 <- subset(gtf, type == "gene" & gene == "grid2")
gene_start <- start(gene_grid2)

# Convert exon coordinates to be relative to gene start (1-based)
# Create new ranges relative to the gene sequence
exons_grid2_relative <- GRanges(
  seqnames = "grid2",  # Match the name in our FASTA
  ranges = IRanges(
    start = start(exons_grid2) - gene_start + 1,
    end = end(exons_grid2) - gene_start + 1
  ),
  strand = strand(exons_grid2)
)

## Filter to keep only valid exons ----
valid_exons <- exons_grid2_relative[
  start(exons_grid2_relative) >= 1 & 
  end(exons_grid2_relative) <= width(grid2)
]

cat("\nAfter filtering:\n")
cat("Valid exons:", length(valid_exons), "out of", length(exons_grid2), "\n")

# Verify all are within bounds
all(start(valid_exons) >= 1 & end(valid_exons) <= width(grid2))


## Step 6: Extract Exon Sequences ----
# Ensure sequence names match

# Extract sequences


## Step 7: Count CpG Dinucleotides ----

# Concatenate all exons and count total CpGs
all_exons_concatenated <- unlist(exon_sequences)


## Step 8 : Additional Analyses ----
# Calculate nucleotide frequencies

# Calculate GC content

# Save exon sequences to file
names(exon_sequences) <- paste0("GRID2_exon_", seq_along(exon_sequences))
writeXStringSet(exon_sequences, "grid2_exons.fa")

```




```{r}

sessionInfo()

```


