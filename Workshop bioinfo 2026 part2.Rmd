---
title: "DNA methylation workflow - workshop 2026 part2"
author: "Frédéric Silvestre"
date: "04/02/2026"
output:
  pdf_document: default
  html_document: default
---

This part aims to learn the workflow of differential DNA methylation analysis using Bioconductor packages, such as methylKit. We will work on example data provided by the package.

# 0° Preparation of the working environment


```{r eval=T}
setwd("/Users/fsilvest/Dropbox/studentpack_2026") # adapt to your computer
getwd()

ls()
rm(list = ls())

#tempdir() #where to save temporary data from R
#list.files(tempdir())

#unlink(tempdir(), recursive = TRUE) # To clean the tempdir. The temp directory usually cleans itself up when you close R. Only use this if you're experiencing specific issues with temp files, and always restart R immediately afterward

#dev.list()
#dev.off() #to reset the graph device options

```


```{r}
#if (!require("stringi", quietly = TRUE)) {
#      install.packages("stringi",type="mac.binary") 
#      library(stringi)}

#mac.binary > if an error message appears (aucun package nommé ‘stringi’ n'est trouvé)

bioc_packages <- c("GenomicRanges", "GenomeInfoDb", "IRanges", "Biostrings", "BSgenome", "AnnotationHub", "GenomicFeatures", "SGSeq", "qvalue", "pwalign", "methylKit", "ShortRead","genomation", "remotes", "txdbmaker", "fastqcr", "Rqc", "QuasR", "methylKit")  

cran_packages <- c("factoextra", "gridExtra", "ggplot2", "psych", "diptest", "MASS", "pheatmap")


for (pkg in bioc_packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
        BiocManager::install(pkg, ask = FALSE)
    }
    library(pkg, character.only = TRUE)
}


for (pkg in cran_packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
        install.packages(pkg, dependencies = TRUE)
    }
    library(pkg, character.only = TRUE)
}

```


# 1° Working on DNA methylation data with methylKit package


## Data filtering and exploratory analyses

We start the analysis with the methylation call file after the alignment with Bismark.
Create a file.list object from the txt files. System.file means the file where the packages are installed: This function is meant to intercept calls to system.file, so that it behaves well with packages loaded by devtools. It is made available when a package is loaded with load_all.
Example here with the package methylKit. Two files for the control and 2 for the treatment.

The location is: [1] "/Library/Frameworks/R.framework/Versions/4.5/Resources/library/methylKit/extdata/test1.myCpG.txt"
Press option while clicking on go to in the finder (Bibliothèque = Library). It will show the hidden files.
Or press fn + Command + shift + . in the finder to show the hidden files.

```{r}

system.file() #to find your system file
system.file(package="methylKit")

?system.file

a <- system.file("extdata", "test1.myCpG.txt", package="methylKit")
a

file.list <- list( system.file("extdata", 
                            "test1.myCpG.txt", package = "methylKit"),
                system.file("extdata",
                            "test2.myCpG.txt", package = "methylKit"),
                system.file("extdata", 
                            "control1.myCpG.txt", package = "methylKit"),
                system.file("extdata", 
                            "control2.myCpG.txt", package = "methylKit") )

file.list
```

MethRead function
Now we can read the files and transform it into a **methylRawList** object (=list of methylRaw objects).
Tab-separated bedgraph like formats from Bismark methylation caller can also be read in by methylkit. In those cases, we have to provide either pipeline="bismarkCoverage" or pipeline="bismarkCytosineReport" to methRead function.
According to Liu 2020, a 30X coverage is the ideal balance.

```{r}

myobj <- methRead(file.list,
           sample.id=list("test1","test2","ctrl1","ctrl2"),
           assembly="hg18",
           treatment=c(1,1,0,0),
           context="CpG",
           dbdir = getwd(),
           mincov = 30
           )

?methRead

#characterize myobj
class(myobj)

length(myobj)
head(myobj)

myobj[[1]]
coverage_values <- myobj[[1]]$coverage
coverage_values

#change the parameters
# how many rows are there using mincov of 10 ?

myobj10 <- methRead(file.list,
           sample.id=list("test1","test2","ctrl1","ctrl2"),
           assembly="hg18",
           treatment=c(1,1,0,0),
           context="CpG",
           dbdir = getwd(),
           mincov = 10
           )

head(myobj10)

#We can change the arguments: header, context, resolution, dbdir

```


Further quality check from the read files.
Distribution of the %methylation.

```{r}

getMethylationStats(myobj[[1]],plot=T,both.strands=F)

?getMethylationStats

#to plot the 4 objects
plotMethylationStats <- function(myobj, plot = TRUE, both.strands = FALSE) {
for (i in 1:4) {
    getMethylationStats(myobj[[i]], plot = T, both.strands = F)
  }
}

par(mfrow = c(2, 2))
plotMethylationStats(myobj)
par(mfrow = c(1, 1))


#extract the median values from the 4 objects
extractMedianMethylation <- function(myobj) {
  median_values <- numeric(4)
    for (i in 1:4) {
    methylation_levels <- myobj[[i]]$numCs / (myobj[[i]]$numCs + myobj[[i]]$numTs)
    median_values[i] <- median(methylation_levels, na.rm = T)
  }
  return(median_values)
}

extractMedianMethylation(myobj)

```


We plot the coverage values (we usually keep fragments with cov > 10 but a too high value means problems with the PCR).
Very high coverage at a CpG site may indicate PCR duplicates—artificially amplified fragments from the same original DNA molecule.
This can skew methylation percentages, over-representing some CpGs.
Some CpG sites with extremely high coverage may result from multi-mapping reads (reads aligning to multiple locations in the genome).
This is common in repetitive regions, leading to artificially inflated methylation values.

```{r}

getCoverageStats(myobj[[1]],plot=T,both.strands=FALSE)

#what is the percentage of bases covered more than 526 times for sample 1 ?
#xxx


#to plot the 4 objects
plotCoverageStats <- function(myobj, plot = TRUE, both.strands = FALSE) {
for (i in 1:4) {
    getCoverageStats(myobj[[i]], plot = T, both.strands = F)
  }
}

par(mfrow = c(2, 2))
plotCoverageStats(myobj)
par(mfrow = c(1, 1))

```

We should now filter out the fragments with lower than 10 coverage and too high coverage (> 99.9% percentile of the sample).

```{r}
filtered.myobj <- filterByCoverage(myobj,lo.count=10,lo.perc=NULL,
                                      hi.count=NULL,hi.perc=99.9)
?filterByCoverage

# What is now the 99.9% percentile coverage ?
#xxx
#xxx

```


Merging the files in a single object.

Setting destrand=TRUE (the default is FALSE) will merge reads on both strands of a CpG dinucleotide. This provides better coverage, but only advised when looking at CpG methylation (for CpH methylation this will cause wrong results in subsequent analyses). In addition, setting destrand=TRUE will only work when operating on base-pair resolution, otherwise setting this option TRUE will have no effect.

```{r}

meth <- methylKit::unite(filtered.myobj, destrand=T)
meth
?methylKit::unite

```


By default, unite function produces bases/regions covered in all samples. That requirement can be relaxed using “min.per.group” option in unite function.

```{r}
# creates a methylBase object, 
# where only CpGs covered with at least 1 sample per group will be returned

meth.min <- unite(myobj,min.per.group=1L, destrand=T)

meth.min

#How many CpG are there ? 
#what is the location of the first CpG of the table ?

```


### Filtering CpG

To remove different CpG based on criteria. For example, we can keep only the CpG with a minimum variation (and not the ones showing mutation C > T).
Below, we extract percent methylation values from CpGs as a matrix. Calculate standard deviation for each CpG and filter based on standard deviation. We also plot the distribution of per CpG standard deviations.


```{r}

pm=percMethylation(meth) # get percent methylation matrix
head(pm)
pm

mds=matrixStats::rowSds(pm) # calculate standard deviation of CpGs
summary(mds)
mds

hist(mds,col="cornflowerblue",xlab="Std. dev. per CpG")

#subsample CpG with a SD higher than 10 and compare the histogram of SD distribution with non-filtered CpG > SMVs (single methytion variant)

methsd10 <- meth[!mds<10,]
methsd10
meth

pm10 <- percMethylation(methsd10)
mds10=matrixStats::rowSds(pm10) # calculate standard deviation of CpGs

par(mfrow=c(1,2))
hist(mds10,col="red",xlab="Std. dev. per CpG", xlim=c(0,40))
hist(mds,col="cornflowerblue",xlab="Std. dev. per CpG")
par(mfrow=c(1,1))

```


Now, let’s assume we know the locations of C->T mutations. These locations should be removed from the analysis as they do not represent bisulfite treatment associated conversions. Mutation locations are stored in a GRanges object, and we can use that to remove CpGs overlapping with mutations. In order to do overlap operation, we will convert the methylKit object to a GRanges object and do the filtering with %over% function within [ ]. The returned object will still be a methylKit object.

```{r}

mut=GRanges(seqnames=c("chr21","chr21"),
            ranges=IRanges(start=c(9860126, 9944505),
                           end=c(9860126, 9944505)))
mut

# select CpGs that do not overlap with mutations
sub.meth=meth[! as(meth,"GRanges") %over% mut,]
nrow(meth)
nrow(sub.meth)

sub.meth


#subset one or several CpG in a region
query_region <- GRanges(seqnames="chr21",ranges = IRanges(start = 9944662, end = 9959407))

hits <- findOverlaps(as(sub.meth, "GRanges"), query_region)

filtered_rows <- sub.meth[queryHits(hits)]
print(filtered_rows)

#validate that we actually deleted the 2 CpG that are a mutation C>T

query_region <- GRanges(seqnames="chr21",ranges = IRanges(start = 9860126, end = 9860126))

hits <- findOverlaps(as(sub.meth, "GRanges"), query_region)

filtered_rows <- sub.meth[queryHits(hits)]
print(filtered_rows)

```


### Searching for CpG with high variability (Single Methylation Variant)

We can analyse the coefficient of variability for each group.

```{r}

pm=percMethylation(meth) # get percent methylation matrix ; only on CpG in all samples
head(pm, 10)

#What are the average CpG %methylation in CTL1 sample ?

summary(pm)

#calculate coefficient of variation for each CpG in CTL and in test

CV <- function(x){sd(x)/mean(x)*100}

CTL <- apply(pm[,3:4], MARGIN=1,FUN = CV)
summary(CTL)
CTL
hist(CTL)

test <- apply(pm[,1:2], MARGIN=1,FUN = CV)
summary(test)
test

# What is the average CV for all groups together ?

CVall <- apply(pm[,1:4], MARGIN=1,FUN = CV)
summary(CVall)
CVall

```

SMVs (Single Methylation Variants) are individual CpG sites that show unusually variable methylation across samples compared to other CpG sites.
We can search for SMVs (single methylation variant) using the interquartile range method.

The Interquartile Range (IQR) Method
The IQR method identifies SMVs by looking for CpGs with unusually high variance:
How it works:

Calculate variance of methylation percentage for each CpG across all samples
Calculate IQR of all these variances:

Q1 = 25th percentile 
Q3 = 75th percentile
IQR = Q3 - Q1


Define outliers as CpGs with variance above a threshold:

Typical threshold: Q3 + 1.5 × IQR (standard outlier definition)
These high-variance CpGs are your SMVs

```{r}

pm
variance <- apply(pm, 1, var)
variance
IQR <- apply(pm, 1,IQR) #we calculate the interquartile range (difference between Q25 and Q75)
IQR
tpm <- t(pm) #transpose rows in columns
tpm
dpm <- describe(tpm)
dpm
describe(dpm)
dpm <- cbind(dpm, IQR)
dpm
hist(dpm$IQR) #check the distribution of IQR
abline(v = 20, col = "red", lwd = 2)

dpm20 <- dpm[dpm[,"IQR"] > 20,]
dpm20
row_indices <- dpm20[, 1]
pm20 <- pm[row_indices,]
pm20

dt <- apply(pm20, 1, function(row) dip.test(row)) #test for unimodality
pval_diptest <- sapply(dt, function(res) res$p.value)
pval_diptest

dpm20 <- cbind(dpm20, pval_diptest)
dpm20 <- filter(dpm20, pval_diptest<0.05)
dpm20

plot(density(pm[7,]), main="Kernel Density Estimate 11937", xlab="% methylation", col="blue") #create a graph to see the bimodal distribution
nrow(dpm20)

par(mfrow = c(3, 6), mar = c(3.5, 3.5, 2.5, 0.5))

row_indices <- as.numeric(rownames(dpm20))

for (i in 1:16) {
  idx <- row_indices[i]
  pval <- dpm20$pval_diptest[i]

  plot(density(pm[idx, ]), 
       main = paste("CpG", idx),
       xlab = "% methylation",
       ylab = "Density",
       col = "blue",
       lwd = 2,
       cex.main = 1,
       cex.lab = 0.8)
  text(x = par("usr")[2] * 0.95,  # 95% of x-axis max
       y = par("usr")[4] * 0.95,  # 95% of y-axis max
       labels = paste("p =", format(pval, digits = 3)),
       adj = c(1, 1),  # Right and top justified
       cex = 0.8)
}

par(mfrow = c(1, 1))  # Reset

nrow(dpm20)/nrow(pm)*100

```


## Multivariate analysis 

Only on a matrix with no NA (CpG in all samples)

Search for correlations between samples:

```{r}

getCorrelation(meth,plot=TRUE)

getCorrelation(meth,plot=F)

```

Clustering samples to group data points by their similarity.

```{r}

clusterSamples(meth, dist="correlation", method="ward.D", plot=TRUE)

#Setting the plot=FALSE will return a dendrogram object which can be manipulated by users or fed in to other user functions that can work with dendrograms.

hc = clusterSamples(meth, dist="correlation", method="ward.D", plot=FALSE)
hc
hc[[1]]

?kmeans

cl=kmeans(t(percMethylation(meth)),centers=2)
cl$cluster

```


Perform PCA.
Here we plot a screen plot for importance of components.

```{r}

PCASamples(meth, obj.return=F, adj.lim=c(1,1))

pc <- PCASamples(meth,obj.return = T, adj.lim=c(1,1), comp = c(1,2))

fviz_pca_biplot(pc, repel = T)

# Eigenvalues
eig.val <- get_eigenvalue(pc)
eig.val

fviz_eig(pc)

```


In this case, we also returned an object from the plotting function. This is the output of R prcomp function, which includes loadings and eigen vectors which might be useful. You can also do your own PCA analysis using percMethylation and prcomp. In the case above, the methylation matrix is transposed. This allows us to compare distances between samples on the PCA scatterplot.


Perform Discriminant Analysis

```{r}
meth
# 1. Prepare data
meth_matrix_clean <- na.omit(t(percMethylation(meth)))
groups <- factor(c(rep("test", 2), rep("control", 2)))

# Function to check variance within groups (LDA can't use CpG with variance = 0)
check_variance <- function(x, groups) {
  sapply(1:ncol(x), function(i) {
    # Check variance within each group
    group_vars <- tapply(x[, i], groups, var, na.rm = TRUE)
    # Return TRUE if any group has zero variance
    any(group_vars == 0 | is.na(group_vars))
  })
}

# Identify problematic variables
const_vars <- check_variance(meth_matrix_clean, groups)
const_vars

# Remove them
meth_filtered <- meth_matrix_clean[, !const_vars]

cat("Removed", sum(const_vars), "constant variables\n")
cat("Remaining variables:", ncol(meth_filtered), "\n")


# 2. Run LDA
lda_result <- lda(meth_filtered, grouping = groups)
predictions <- predict(lda_result)


# 3. Visualize
plot(predictions$x, 
     col = as.numeric(groups) + 1,
     pch = 19, cex = 2,
     xlab = "LD1",
     main = "Linear Discriminant Analysis")
legend("topright", legend = levels(groups), col = 2:3, pch = 19)


# 4. Evaluate classification performance 

# Confusion matrix
confusion <- table(Predicted = predictions$class, Actual = groups)
print(confusion)

# Calculate accuracy
accuracy <- sum(diag(confusion)) / sum(confusion) * 100
cat("Classification accuracy:", round(accuracy, 1), "%\n")

# Posterior probabilities (confidence of classification)
print(predictions$posterior)

# Visualize posterior probabilities
barplot(t(predictions$posterior), 
        beside = TRUE,
        col = c("red", "blue"),
        legend = levels(groups),
        main = "Classification probabilities",
        xlab = "Sample",
        ylab = "Posterior probability")


# Identify most discriminative CpGs

# Extract LDA coefficients (loadings)
loadings <- lda_result$scaling[, 1]  # First discriminant

# Sort by absolute value (most important)
top_indices <- order(abs(loadings), decreasing = TRUE)[1:20]

# Create dataframe
top_cpgs <- data.frame(
  Rank = 1:20,
  CpG_index = top_indices,
  LD1_coefficient = loadings[top_indices],
  abs_coefficient = abs(loadings[top_indices])
)

print(top_cpgs)

# Visualize top discriminative CpGs
par(mar = c(5, 10, 4, 2))
barplot(top_cpgs$LD1_coefficient[20:1],
        horiz = TRUE,
        names.arg = top_cpgs$CpG_index[20:1],
        col = ifelse(top_cpgs$LD1_coefficient[20:1] > 0, "red", "blue"),
        main = "Top 20 discriminative CpGs",
        xlab = "LDA coefficient",
        las = 1)
abline(v = 0, lty = 2)
legend("bottomright", 
       legend = c("Enriched in Treatment", "Enriched in Control"),
       fill = c("red", "blue"))


```



## Batch control

We have implemented some rudimentary functionality for batch effect control. You can check which one of the principal components are statistically associated with the potential batch effects such as batch processing dates, age of subjects, sex of subjects using assocComp. The function gets principal components from the percent methylation matrix derived from the input methylBase object, and checks for association. The tests for association are either via Kruskal-Wallis test or Wilcoxon test for categorical attributes and correlation test for numerical attributes for samples such as age. If you are convinced that some principal components are accounting for batch effects, you can remove those principal components from your data using removeComp.

```{r}

# make some batch data frame
# for the example data

sampleAnnotation=data.frame(batch_id=c("a","a","b","b"),
                            age=c(19,37,35,17))

sampleAnnotation

as=assocComp(mBase=meth,sampleAnnotation)
as


#visualize the batch effects

assoc_matrix <- as$association

pheatmap(assoc_matrix,
         cluster_rows = FALSE,
         cluster_cols = FALSE,
         main = "PC-Covariate Associations",
         display_numbers = TRUE,
         number_format = "%.2f",
         color = colorRampPalette(c("blue", "white", "red"))(100))


#if we want to remove one component:
newObj=removeComp(meth,comp=4)
newObj
as2=assocComp(mBase=newObj,sampleAnnotation)
as2

#we can't do the analysis if we have NA > use the meth before filtering
is.na(meth)

```



## Analysis on regions

For some situations, it might be desirable to summarize methylation information over tiling windows rather than doing base-pair resolution analysis. methylKit provides functionality to do such analysis. The function below tiles the genome with windows of 1000bp length and 1000bp step-size and summarizes the methylation information on those tiles. In this case, it returns a methylRawList object which can be fed into unite and calculateDiffMeth functions consecutively to get differentially methylated regions. The tilling function adds up C and T counts from each covered cytosine and returns a total C and T count for each tile.

As mentioned before, methRead sets a minimum coverage threshold of 10 reads per cytosine to ensure good quality for downstream base-pair resolution analysis. However in the case of tiling window / regional analysis one might want to set the initial per base coverage threshold to a lower value and then filter based on the number of bases (cytosines) per region. Filtering samples based on read coverage might still be appropriate to remove coverage biases.

```{r}

myobj_lowCov = methRead(file.list,
           sample.id=list("test1","test2","ctrl1","ctrl2"),
           assembly="hg18",
           treatment=c(1,1,0,0),
           context="CpG",
           mincov = 3
           )

tiles = tileMethylCounts(myobj,win.size=1000,step.size=1000,cov.bases = 0)
tiles

# unite the different samples including all replicates in each group
# what is the start and end location of the first tile on the table ?

tile <- methylKit::unite(tiles, destrand=FALSE, min.per.group = NULL)

tile
head(tiles)

```



# 2° Extracting regions of interest

Search for differentially methylated CpG sites or regions.
Usually using Fisher's exact test and methylKit package or logistic regression. Here we show for one sample per group (Fisher).

calculateDiffMeth: The function calculates differential methylation statistics between two groups of samples. The function uses either logistic regression test or Fisher's Exact test to calculate differential methylation.

We can add overdispersion, covariate and the method of adjustment (SLIM by deffault, or BH, bonferroni, fdr, qvalue).
The q-value is the False Discovery Rate (FDR)-adjusted p-value, used to correct for multiple testing. It represents the minimum FDR at which a given CpG site is considered significant.

```{r}

getSampleID(meth)

new.meth <- reorganize(meth,sample.ids=c("test1","ctrl1"),treatment=c(1,0))
new.meth

dmf <- calculateDiffMeth(new.meth, overdispersion = NULL, covariate=NULL, adjust = "SLIM", test="fast.fisher")

dmf

?calculateDiffMeth

```

As mentioned, we can also pool the samples from the same group by adding up the number of Cs and Ts per group. This way even if we have replicated experiments we treat them as single experiments, and can apply Fisher’s exact test. We will now pool the samples and apply:


```{r}
pooled.meth=pool(meth,sample.ids=c("test","control"))
dm.pooledf=calculateDiffMeth(pooled.meth)
dm.pooledf
```

CalculateDiffMeth function returns the P-values for all bases or regions in the input methylBase object. We need to filter to get differentially methylated CpGs. This can be done via getMethlyDiff function or simple filtering via [ ] notation. Below we show how to filter the methylDiff object output by calculateDiffMeth() function in order to get differentially methylated CpGs. The function arguments defines cutoff values for the methylation difference between groups and Q-value. In these cases, we require a methylation difference of 10% and Q-value of at least 0.01.

```{r}
?getMethylDiff

# get differentially methylated bases/regions with specific cutoffs

all.diff=getMethylDiff(dmf,difference=10,qvalue=0.01,type="all")
all.diff

# get hyper-methylated
hyper=getMethylDiff(dmf,difference=10,qvalue=0.01,type="hyper")
hyper

# get hypo-methylated
hypo=getMethylDiff(dmf,difference=10,qvalue=0.01,type="hypo")
hypo

#using [ ] notation
hyper2=dmf[dmf$qvalue < 0.01 & dmf$meth.diff > 10,]
hyper2
```

*Logistic regression based tests.*
However, linear-regression-based methods might produce fitted methylation levels outside the range
[0,1] unless the values are transformed before regression. An alternative is logistic regression, which can deal with data strictly bounded between 0 and 1 and with non-constant variance, such as methylation proportion/fraction values.
If the observed variance is larger or smaller than assumed by the model, one speaks of under- or over-dispersion. This over/under-dispersion can be corrected by calculating a scaling factor and using that factor to adjust the variance estimates.
MethylKit can apply logistic regression to test the methylation difference with or without the over-dispersion correction. In this case, Chi-square or F-test can be used to compare the difference in the deviances of the null model and the alternative model. The null model assumes there is no relationship between sample groups and methylation, and the alternative model assumes that there is a relationship where sample groups are predictive of methylation values for a given CpG or region for which the model is constructed. Next, we are going to use the logistic regression based model with over-dispersion correction and Chi-square test. Cfr book.

Overdispersion occurs when the observed variance is higher than the variance of a theoretical model. 


*Exercise to change the parameters.*

```{r}

# work on the meth object including 2 replicates per condition
# calculate the differential methylation with your chosen parameters

#xxx

#xxx

```

Traditional Benjamini-Hochberg (BH) assumes a uniform distribution of p-values, which may not always be accurate in methylation datasets.
SLIM adapts to the actual p-value distribution, potentially increasing statistical power while maintaining FDR control.
SLIM can detect more differentially methylated sites (DMS/DMRs) compared to BH, especially when many sites show small but significant changes.


```{r}

# get differentially methylated bases/regions with a cutoff of 20 and a qvalue of 0.05
# how many CpG are significant ?
# how many are hypo-methylated ?

#xxx
#xxx

# get hypo-methylated
#xxx
#xxx

#Compare the results using BH and SLIM

#xxx
#xxx

#xxx
#xxx
#xxx
```

*Best choice*

For a standard biological experiment with replicates of minimum 5 > overdispersion "MN", test "Chisq", adjust "SLIM".



More complex regression models use beta binomial distribution and are particularly useful for better modeling the variance. Similar to logistic regression, their observation follows binomial distribution (number of reads), but methylation proportion itself can vary across samples, according to a beta distribution. It can deal with fitting values in the (0,1) range and performs better when there is greater variance than expected by the simple logistic model. In essence, these models have a different way of calculating a scaling factor when there is over-dispersion in the model. Further enhancements are made to these models by using the empirical Bayes methods that can better estimate hyper parameters of the beta distribution (variance-related parameters) by borrowing information between loci or regions within the genome to aid with inference about each individual loci or region. 
We are now going to use a *beta-binomial* based model called DSS(Feng, Conneely, and Wu 2014) to calculate differential methylation.
Beta-binomial model models overdispersion but is more intensive. Can't use covariate (except with DSS.general).

DSS is better for small sample size

```{r}

dm.dss=calculateDiffMethDSS(meth, adjust = "SLIM")
dm.dss

# how many CpG are differentially methylated ?

all.diffdss=getMethylDiff(dm.dss,difference=20,qvalue=0.05,type="all")
all.diffdss

```

We can perform the analysis by region.
The function below tiles the genome with windows 1000bp length and 1000bp step-size and summarizes the methylation information on those tiles. In this case, it returns a methylRawList object which can be fed into unite and calculateDiffMeth functions consecutively to get differentially methylated regions.

```{r}

tiles.dss=calculateDiffMethDSS(tile, adjust = "SLIM")
tiles.dss

tiles.diff=getMethylDiff(tiles.dss,difference=20,qvalue=0.05,type="all")
tiles.diff

#Compare the DSS and the logistic regression methods

```




## Adding covariates.

Covariates can be included in the analysis as well in methylKit. The calculateDiffMeth function will then try to separate the influence of the covariates from the treatment effect via the logistic regression model. In this case, we will test if full model (model with treatment and covariates) is better than the model with the covariates only. If there is no effect due to the treatment (sample groups), the full model will not explain the data better than the model with covariates only. In calculateDiffMeth, this is achieved by supplying the covariates argument in the format of a data.frame. Below, we simulate methylation data and add make a data.frame for the age. The data frame can include more columns, and those columns can also be factor variables. The row order of the data.frame should match the order of samples in the methylBase object. Below we are showing an example of this using a simulated data set where methylation values of CpGs will be affected by the age of the sample.

```{r}

covariates=data.frame(age=c(30,80,34,30,80,40))
sim.methylBase=dataSim(replicates=6,sites=1000,
                        treatment=c(rep(1,3),rep(0,3)),
                        covariates=covariates,
                        sample.ids=c(paste0("test",1:3),paste0("ctrl",1:3)))

my.diffMeth3=calculateDiffMeth(sim.methylBase,
                               covariates=covariates,
                               overdispersion="MN",
                               test="Chisq")
my.diffMeth3
getMethylDiff(my.diffMeth3,difference=10,qvalue=0.01,type="all")


#Include the covariate age to the meth object with c(30, 80, 30, 80)
# calculate the differential methylation with your favorite parameters
# how many CpG are DMC ?

#xxx
#xxx
#xxx
#xxx
#xxx
#xxx
#xxx
#xxx
#xxx

```





# 3° Annotation of DMR/DMC

Below, we are reading a BED file for transcripts and using that to annotate DMCs with promoter/intron/exon/intergenic annotation.genomation::readTranscriptFeatures function reads a BED12 file, calculates the coordinates of promoters, exons and introns and the subsequent function uses that information for annotation.

One of larger hindrances in computational genomics stems from the myriad of formats that are used to store the data. Although some formats have been selected as de facto standards for specific kind of biological data (e.g. BAM, VCF), almost all publications come with supplementary tables that do not have the same structure, but hold similar information. The tables usually have a tabular format, contain the location of elements in genomic coordinates and various metadata colums. genomation contais functions to read genomic intervals and genomic annotation provided they are in a tabular format. These functions will read the data from flat files into GRanges or GRangesList objects.

readGeneric is the workhorse of the genomation package. It is a function developed specifically for input of genomic data in tabular formats, and their conversion to a GRanges object. By default, the function persumes that the file is a standard .bed file containing columns chr, start, end.

```{r}

browseVignettes("genomation")

# read the gene BED file
transcriptBED=system.file("extdata", "refseq.hg18.bed.txt", 
                                           package = "methylKit")

readGeneric(transcriptBED, header=T, keep.all.metadata=F)

gene.obj=readTranscriptFeatures(transcriptBED)
class(gene.obj)
gene.obj

promoters=regionCounts(myobj,gene.obj$promoters)
promoters

# annotate differentially methylated CpGs with 
# promoter/exon/intron using annotation data
#
annotateWithGeneParts(as(all.diff,"GRanges"),gene.obj)


```

Similarly, we can read the CpG island annotation and annotate our differentially methylated bases/regions with them.

```{r}

# read the shores and flanking regions and name the flanks as shores 
# and CpG islands as CpGi

cpg.file=system.file("extdata", "cpgi.hg18.bed.txt",package = "methylKit")

cpg.obj=readFeatureFlank(cpg.file,
                           feature.flank.name=c("CpGi","shores"))
head(cpg.obj)
#
# convert methylDiff object to GRanges and annotate
diffCpGann=annotateWithFeatureFlank(as(all.diff,"GRanges"),
                                    cpg.obj$CpGi,cpg.obj$shores,
                         feature.name="CpGi",flank.name="shores")
diffCpGann
```

