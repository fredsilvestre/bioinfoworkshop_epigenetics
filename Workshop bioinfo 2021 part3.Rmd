---
title: "kmarEE2"
author: "Me"
date: "1/7/2021"
output: html_document
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE, include=TRUE, cache=TRUE, results="hide", warning=FALSE, error=TRUE, eval=FALSE)
```

Change the general options in each chunk: eval=T (run the chunk); results=markup (show the results)
Option/Command I to create a chunk
Shift/option ( to [
Option ( to {
| shift/option L
~ option n


#set working directory 

```{r}
getwd()
setwd("~/methylome")
ls()
rm(list = ls())
tempdir() #save all the data from R
#to open /var folder > command + shift + G (write /var)
```
#install R v4 and R studio v 1.4

# install Bioconductor 3.12
Bioconductor: https://www.bioconductor.org/
search for available packages: https://www.bioconductor.org/packages/release/BiocViews.html#___Software

```{r}
# Check the version of BiocManager on your computer
BiocManager::version()

if(!requireNamespace("BiocManager", quietly=TRUE))
        install.packages("BiocManager")
BiocManager::install(version="3.12")

library(BiocManager)

#To check the number of packages available in Bioconductor
avail <- BiocManager::available()
length(avail)
avail
#update your packages
BiocManager::install()

```

#To obtain help

```{r}
?mean
help.start()
sessionInfo()
help(package = "Biobase")
vignette(package="Biobase")
vignette("ExpressionSetIntroduction")
browseVignettes(package="Biobase")
```



```{r}

#pacman package to install and load packages automatically 
if(!require(pacman)){install.packages("pacman");require(pacman)}

if(!require(c("Rqc", "methylKit", "ShortRead", "QuasR"))){
BiocManager::install(c("Rqc", "methylKit", "ShortRead", "QuasR"))}

p_load(Rqc, methylKit, ShortRead, QuasR)



if(!require("remotes")){
    install.packages("remotes")
    library(remotes)
}

```


# To write and read R object in RDS format in the wd

```{r}
saveRDS(myobj, file="myobj.RDS")
b <- readRDS("myobj.RDS")
```


#1° Quality check

Working with FastQ files
In the terminal we can see the file with the 4 lines

zless name.fastq.gz | head

```{r}

folder <- system.file(package="ShortRead", "extdata/E-MTAB-1147")
qcRes <- rqc(path=folder, pattern=".fastq.gz", openBrowser=FALSE)
perFileInformation(qcRes)

rqcCycleQualityBoxPlot(qcRes)
rqcReadQualityBoxPlot(qcRes)
rqcReadQualityPlot(qcRes)

rqcCycleBaseCallsLinePlot(qcRes) # content of bases

rqcReadFrequencyPlot(qcRes) #read freqeuncy plot

getwd()

# same with a file from rivulus (! bug here)
qcRes <- rqc(path="P01-15-trim.fastq.gz", pattern=".fastq.gz", openBrowser=FALSE)

fq <- readFastq("P01-15-trim.fastq.gz") #long time
fq

saveRDS(fq, file="fq.RDS")
b <- readRDS("fq.RDS")

#object ShortReadQ
class(fq)
sequences <- sread(fq)
sequences
id(fq)
#object FastqQuality
qfq <- quality(fq)
qfq
class(qfq)
#to subtract the bases from 1 to 5 from each read; long time
substr(sequences,1,5)

qPerBase=as(quality(fq[1]), "matrix")
qPerBase
qcount=rowSums(qPerBase<=20)
qcount
```


# idem ci-dessous mais pour générer un rapport sous forme de liste 
#on crée ensuite un rapport final en html

```{r}
folder <- system.file(package="ShortRead", "extdata/E-MTAB-1147")
files <- list.files(folder, "fastq.gz", full.names=TRUE)
qa <- rqcQA(files, workers=1)
qa
reportFile <- rqcReport(qa)
browseURL(reportFile)
```


We can use the package fastqcr to aggregate several FASTQC reports in .zip
http://www.sthda.com/english/wiki/fastqcr-an-r-package-facilitating-quality-controls-of-sequencing-data-for-large-numbers-of-samples 

```{r}
install.packages("fastqcr")
library("fastqcr")
```



# 2° Filtrer et trim les reads

```{r}

if(!require("QuasR")){
    BiocManager::install("QuasR")
}
library(QuasR)


fastqFiles <- system.file(package="ShortRead",
                          "extdata/E-MTAB-1147",
                          c("ERR127302_1_subset.fastq.gz",
                            "ERR127302_2_subset.fastq.gz"))
outfiles <- paste(tempfile(pattern=c("processed_1_",
                                     "processed_2_")),".fastq", sep="")
preprocessReads(fastqFiles, outfiles,
                nBases=1,
                truncateEndBases=3,
                Lpattern="ACCCGGGA",
                minLength=40)
library(ShortRead)
fastqFile <- system.file(package="ShortRead",
                          "extdata/E-MTAB-1147",
                          "ERR127302_1_subset.fastq.gz")
fq <- readFastq(fastqFile)
qPerBase=as(quality(fq), "matrix")
qcount=rowSums(qPerBase<=20)
fq[qcount==0]
writeFastq(fq[qcount==0],
           paste(fastqFile, "Qfiltered", sep="_")) #réécrire un nouveau fichier fastq
```

#on rivulus sample from Valentine
trimming of the 3 first bp CGG from the file received from GIGA and already trimmed for adaptors.
```{r}
?preprocessReads
preprocessReads(filename = "P01-15-L_AHV5CKDRXX_S577_L001_R1_001 trim.fastq.gz", outputFilename="P01-15-trim.fastq.gz", truncateStartBases = 3, truncateEndBases= 2, nBases=1)

```



#Load the raw data from BAM files on the harddrive

We must first reorganize the BAM files after Bismark with the samtools package from the terminal

Now we read a file from Bismark with the format .SAM
SAM files must be sorted by chromosome and read position columns, using ‘sort’ command in unix-like machines will accomplish such a sort easily. BAM files should be sorted and indexed. This could be achieved with samtools (http://www.htslib.org/doc/samtools.html).
Follow samtools tutorial: http://quinlanlab.org/tutorials/samtools/samtools.html#:~:text=samtools%20%E2%80%9Csort%E2%80%9D&text=In%20other%20words%2C%20the%20BAM,in%20the%20input%20FASTQ%20files.&text=Doing%20anything%20meaningful%20such%20as,occur%20in%20%E2%80%9Cgenome%20order%E2%80%9D.
List of terminal commands: https://www.makeuseof.com/tag/mac-terminal-commands-cheat-sheet/

cd ~
mkdir methylome
cd ~/methylome
git clone https://github.com/samtools/htslib
git clone https://github.com/samtools/samtools
cd samtools
make
!!!! to use a command while you are in the good directory: ./samtools
cd .. #to come back in methylome
./samtools/samtools view CTL1.bam| head

When you align FASTQ files with all current sequence aligners, the alignments produced are in random order with respect to their position in the reference genome. In other words, the BAM file is in the order that the sequences occurred in the input FASTQ files.

./samtools/samtools sort CTL1.bam -o CTL1.sorted.bam

```{r}
my.methRaw <- processBismarkAln( location = "CTL1.sorted.bam",
                         sample.id="CTL1", assembly="ASM164957v1", 
                         read.context="CpG", save.folder=getwd())

my.methRaw
```
                         
The file has been saved in the wd: CTL1_CpG.txt and CTL1_CpG_conversionStats.txt

We can now do it at once for several files (it takes 6-7min per file)
It's an object methylRawList of 6

```{r}
file.list <- list( "CTL1.sorted.bam", "CTL2.sorted.bam", "CTL3.sorted.bam","CTL4.sorted.bam", "CTL5.sorted.bam", "EE22.sorted.bam", "EE23.sorted.bam", "EE24.sorted.bam", "EE25.sorted.bam")

file.list

myobj <- processBismarkAln(file.list,
           sample.id=list("CTL1","CTL2","CTL3", "CTL4", "CTL5", "EE22", "EE23", "EE24", "EE25"),
           assembly="ASM164957v1",
           treatment=c(1,1,1,1,1,0,0,0,0),
           read.context="CpG",
           save.folder = getwd(),
           mincov = 10
           )

#characterize myobj
length(myobj)
class(myobj)
head(myobj)
?methRead

dir()
file.list <- list("CTL1_CpG.txt", "CTL2_CpG.txt", "CTL3_CpG.txt", "CTL4_CpG.txt", "CTL5_CpG.txt", "EE22_CpG.txt", "EE23_CpG.txt", "EE24_CpG.txt", "EE25_CpG.txt")

myobj <- methRead(file.list,
           sample.id=list("CTL1","CTL2","CTL3", "CTL4", "CTL5", "EE22", "EE23", "EE24", "EE25"),
           assembly="ASM164957v1",
           treatment=c(1,1,1,1,1,0,0,0,0),
           context="CpG",
           mincov = 10
           )

myobj <- readRDS("myobj.RDS")
myobj
head(myobj)
```

# Analyse the CpG on each file and filter to get rid of the low quality

```{r}
par(mfrow = c(1,9))
for(a in 1:9) {getMethylationStats(myobj[[a]], plot=T, strands = F)}
getMethylationStats(myobj[[4]],plot=TRUE,both.strands=F)
?getMethylationStats
```

```{r}
par(mfrow = c(1,9))
for(a in 1:9) {getCoverageStats(myobj[[a]], plot=T, strands = F)}
getCoverageStats(myobj[[1]],plot=T,both.strands=FALSE)
getCoverageStats(myobj[[1]],plot=F,both.strands=FALSE)

?getCoverageStats
```

```{r}
filtered.myobj <- filterByCoverage(myobj,lo.count=10,lo.perc=NULL,
                                      hi.count=NULL,hi.perc=99.9)
getCoverageStats(filtered.myobj[[1]],plot=T,both.strands=FALSE)
getCoverageStats(filtered.myobj[[4]],plot=F,both.strands=FALSE)

```

Exercise to do the same without a minimum coverage
for CTL4 (it takes time to read the bam file ; change the name)

```{r}
myobj4 <- processBismarkAln("CTL4.sorted.bam",
           sample.id="CTL4bis",
           assembly="ASM164957v1",
           read.context="CpG",
           save.folder = getwd(),
           mincov = 0
           )


myobj4 <- methRead("CTL4bis_CpG.txt",
           sample.id="CTL4bis",
           assembly="ASM164957v1",
           mincov = 0
           )

myobj4

getMethylationStats(myobj4,plot=TRUE,both.strands=F)

getCoverageStats(myobj4,plot=T,both.strands=FALSE)

getCoverageStats(myobj4,plot=F,both.strands=FALSE)

```
Results: we have 6,103,000 CpG without coverage of 10
1,112,000 with coverage !



#Unite the different files in the same object

We can set a minimum number of samples covered min.per.group (1L, 2L, 3L)
```{r}
meth <- methylKit::unite(filtered.myobj, destrand=FALSE, min.per.group = NULL)
head(meth)
meth
meth3L <- methylKit::unite(filtered.myobj, destrand=FALSE, min.per.group = 3L)
meth3L
meth1L <- methylKit::unite(filtered.myobj, destrand=FALSE, min.per.group = 1L)
meth1L

```
There are 11,918 CpG analyzed in the unite object for CpG in all samples.
If we limit to minimum 3 samples, we have 976,600
1,131,000 if we take all =± # of CpG total


#See the variability of each CpG and filter the CpGs by the SD and get the percentage methylation Matrix
We also plot this matrix

```{r}
pm=percMethylation(meth) # get percent methylation matrix ; only on CpG in all samples
head(pm)
summary(pm)

#calculate coefficient of variation for each CpG in CTL and in EE2
CV <- function(x){sd(x)/mean(x)*100}

CTL <- apply(pm[,1:5], MARGIN=1,FUN = CV)
summary(CTL)
head(CTL)
EE2 <- apply(pm[,6:9], MARGIN=1,FUN = CV)
summary(EE2)
CVall <- apply(pm[,1:9], MARGIN=1,FUN = CV)
summary(CVall)

hist(CTL)

```


#PCA and clustering 
Only on a matrix with no NA (CpG in all samples)

```{r}
getCorrelation(meth,plot=F)
```

```{r}
clusterSamples(meth, dist="correlation", method="ward", plot=TRUE)
```

```{r}
pc <- PCASamples(meth,obj.return = T, adj.lim=c(1,1), comp = c(1,2))
PCASamples(meth, obj.return=T, transpose=F)

install.packages("factoextra")
library(factoextra)
# Eigenvalues
eig.val <- get_eigenvalue(pc)
eig.val
fviz_eig(pc)

?PCASamples
```


# Make corrections for putative batch effect
For CpG in all samples

```{r}
# make some batch data frame
# this is a bogus data frame
# we don't have batch information
# for the example data
sampleAnnotation=data.frame(batch_id=c("CTL","CTL","CTL","CTL", "CTL", "EE2", "EE2", "EE2", "EE2"),
                            age=c(19,34,100,40, 27, 90, 23, 68, 89),
                            weight=c(28,100,17,90, 35, 89, 20, 101, 21))
sampleAnnotation

#we can't do the analysis if we have NA > use the meth before filtering
is.na(meth3L)

as=assocComp(mBase=meth,sampleAnnotation)
as
?assocComp

#if we want to remove one component:
newObj=removeComp(meth,comp=2)
?removeComp
as2=assocComp(mBase=newObj,sampleAnnotation)
as2

pc2 <- PCASamples(newObj,obj.return = T, adj.lim=c(1,1), comp = c(1,2))

eig.val <- get_eigenvalue(pc2)
eig.val
fviz_eig(pc)

```



#Extracting regions of interest

```{r}
getSampleID(meth3L)
#Reorganize if necessary
new.meth <- reorganize(meth3L,sample.ids=c("test1","ctrl1"),treatment=c(1,0))

```

Calculate the different methylation (it can take few minutes)
Logistic regression
```{r}
?calculateDiffMeth

dm.lr=calculateDiffMeth(meth,overdispersion = "MN",test ="Chisq", covariate=NULL, adjust = "SLIM")

dm.lr
```

Beta binomial distribution
```{r}
dm.dss=calculateDiffMethDSS(meth, adjust = "SLIM")
dm.dss
?calculateDiffMethDSS
```

Determine the cutoffs
```{r}
# get differentially methylated bases/regions with specific cutoffs
all.diff=getMethylDiff(dm.dss,difference=10,qvalue=0.01,type="all")
all.diff
summary(all.diff)
?getMethylDiff

# get hyper-methylated
hyper=getMethylDiff(dmf,difference=25,qvalue=0.01,type="hyper")
hyper

# get hypo-methylated
hypo=getMethylDiff(dmf,difference=25,qvalue=0.01,type="hypo")
hypo

#using [ ] notation
hyper2=dm.pooledf[dm.pooledf$qvalue < 0.01 & dm.pooledf$meth.diff > 25,]
hyper2
```


Correct for covariates
Only for logistic
```{r}
covariates=data.frame(age=c(30,80,34,30,80,40, 30, 40, 90))
#to simulate a data frame of methylation
sim.methylBase=dataSim(replicates=9,sites=1000,
                        treatment=c(rep(1,3),rep(0,3)),
                        covariates=covariates,
                        sample.ids=c(paste0("test",1:3),paste0("ctrl",1:3)))
?dataSim

my.diffMeth3=calculateDiffMeth(sim.methylBase,
                               covariates=covariates,
                               overdispersion="MN",
                               test="Chisq")
my.diffMeth3


covariates <- data.frame(age=c(30,80,34,30,80,40, 30, 40, 90))
my.diffMeth4=calculateDiffMeth(meth3L,
                               covariates=covariates,
                               overdispersion="MN",
                               test="Chisq")
my.diffMeth4

dm.lr=calculateDiffMeth(meth,overdispersion = "MN",test ="Chisq", covariate=NULL, adjust = "SLIM")
dm.lr
```


#Do the analysis on regions and not CpGs
!!! long processing time

```{r}

myobj_lowCov <- methRead(file.list,
           sample.id=list("CTL1","CTL2","CTL3", "CTL4", "CTL5", "EE22", "EE23", "EE24", "EE25"),
           assembly="ASM164957v1",
           treatment=c(1,1,1,1,1,0,0,0,0),
           context="CpG",
           mincov = 3
           )

saveRDS(myobj_lowCov, file="myobj_lowCov.RDS") #to save the object in the wd
a <- readRDS("myobj_lowCov.RDS")

tiles <-  tileMethylCounts(myobj_lowCov,win.size=200,step.size=200,cov.bases = 3)
head(tiles[[1]])
?tileMethylCounts
tiles[[1]]
head(tiles[[1]])
length(tiles)
class(tiles)

saveRDS(tiles, file="tiles1.RDS")
b <- readRDS("tiles1.RDS")

#unite
alltiles <- methylKit::unite(b, destrand=FALSE, min.per.group = NULL)
alltiles
```
After unite, we have 86 678 regions

```{r}
pmat=percMethylation(alltiles) # get percent methylation matrix ; only on CpG in all samples
head(pmat)
summary(pmat)

#calculate coefficient of variation for each CpG in CTL and in EE2
CV <- function(x){sd(x)/mean(x)*100}

CTL <- apply(pmat[,1:5], MARGIN=1,FUN = CV)
summary(CTL)
head(CTL)
EE2 <- apply(pmat[,6:9], MARGIN=1,FUN = CV)
summary(EE2)
CVall <- apply(pmat[,1:9], MARGIN=1,FUN = CV)
summary(CVall)

hist(CTL)

```
The mean %met is now around 70%. CV around 9%

```{r}
c <- readRDS("tiles.diff.RDS")
c

tiles.dss=calculateDiffMethDSS(alltiles, adjust = "SLIM")
tiles.dss

dm.lr=calculateDiffMeth(alltiles,overdispersion = "MN",test ="Chisq", covariate=NULL, adjust = "SLIM")
dm.lr

tiles.diff=getMethylDiff(tiles.dss,difference=10,qvalue=0.01,type="all")
tiles.diff

saveRDS(tiles.diff, file="tiles.diff.RDS")

tiles.diff2=getMethylDiff(tiles.dss,difference=10,qvalue=0.01,type="all")
tiles.diff2

#save a nice table
install.packages("kableExtra") #https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html
library(kableExtra)
webshot::install_phantomjs() #to be able to export tables with save_kable()

kbl <- kbl(tiles.diff)
kbl
table1 <- tiles.diff %>% kbl(caption="Regions of 200 bp that are significantly over or under methylated in EE2") %>% kable_classic("striped",full_width=F) %>%
        column_spec(1, bold=T)
table1
install.packages("magick")
library(magick)
save_kable(table1, file="all.diff.png")  


```


#Annotation

```{r}
gff.file = system.file("extdata/chr21.refseq.hg19.gtf", package = "genomation")
gff = gffToGRanges(gff.file)
head(gff)

#we can start from a gtf file from rivulus:
gffkmar <- gffToGRanges("/Users/fsilvestre/Documents UNamur/Frederic URBE/Recherche/Protocoles & methods/Statistic methods/Omics data analysis/set directory/kmargtf.gtf")
head(gffkmar)
unique(gffkmar$type)
gffToGRanges(gffkmar)
````
